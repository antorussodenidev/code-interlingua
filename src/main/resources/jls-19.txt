// This grammar is extracted from the "Java Language Specification"
// Chapter 19 which gathers together the grammar productions from
// the rest of the spec.
// https://docs.oracle.com/javase/specs/jls/se8/html/jls-19.html

// Section 2.4 of the JLS defines the syntax.
// The fixed-width sections are quoted, and "one of" productions are
// expanded to one per line.

// This grammar is examined by generate_parser_helpers.py to
// produce *ParSerHelper.java classes which are references in
// NodeType classes.
// If there is one in the source tree,
// or the production starts with "TODO" then no
// helper is generated.


/*
This is brittle, but I produced the bulk of this file thus:

curl https://docs.oracle.com/javase/specs/jls/se8/html/jls-19.html \
    > /tmp/jls-19.html

And then adding the following to the bottom before the </body>,
loading it in a browser and copy/pasting the text form.

<pre id="text-grammar"></pre>
<script>
  function strip(s) {
    return String(s).replace(/^\s+|\s+$/g, '');
  }

  var specialProds = {
    Identifier: 'builtin',  // Lexical production
    IdentifierChars: 'builtin',
    JavaLetter: null,  // Not needed post-lex
    JavaLetterOrDigit: null,
    IntegerLiteral: 'builtin',
    FloatingPointLiteral: 'builtin',
    StringLiteral: 'builtin',
    CharacterLiteral: 'builtin',
  };

  var output = '';
  var prods = document.querySelectorAll('.production');
  var seen = {};
  for (var i = 0, n = prods.length; i !== n; ++i) {
    var prod = prods[i];
    var lhs  = prod.querySelector('.lhs');
    var rhs  = prod.querySelector('.rhs');
    var name = strip(lhs.textContent);
    var variant = [];
    var variants = [];
    function processRhs(rhsNodes) {
      for (var i = 0, n = rhsNodes.length; i !== n; ++i) {
        var rhsNode = rhsNodes[i];
        switch (rhsNode.nodeType) {
          case Node.TEXT_NODE:
            var text = strip(rhsNode.nodeValue);
            var parts = rhsNode.nodeValue.match(/\S+/g);
            if (parts) {
              for (var j = 0, m = parts.length; j !== m; ++j) {
                variant.push(parts[j]);
              }
            }
            break;
          case Node.ELEMENT_NODE:
            switch (rhsNode.tagName) {
              case 'BR':
                if (variant.length) {
                  variants.push(variant.join(' '));
                  variant.length = 0;
                }
                break;
              case 'A':  // Reference to production
                variant.push(strip(rhsNode.textContent));
                break;
              case 'SPAN':
                variant.push('/' + '*' + strip(rhsNode.textContent) + '*' + '/');
                break;
              case 'CODE':  // Literal.  Quoted strings in lexical grammar not here.
                variant.push('"' + strip(rhsNode.textContent) + '"');
                break;
              case 'PRE':
                processRhs(rhsNode.childNodes);
                break;
              default:
                throw new Error(rhs.tagName + ' not expected');
            }
            break;
        }
      }
    }
    processRhs(rhs.childNodes);
    if (variant.length) { variants.push(variant.join(' ')); }
    var variantBreak = '\n     ';
    var variantsOutput = variants.join(variantBreak);
    var noOneOf = variantsOutput.replace(/^\s*\(one of\)(?:\s*)/, '');
    if (noOneOf != variantsOutput) {
      variantsOutput = noOneOf.replace(/\s+/g, variantBreak);
    }
    // Handle lexical productions by mapping them to "builtin".
    var prodName = lhs.textContent.replace(/:$/, '');
    seen[prodName] = true;
    if (Object.hasOwnProperty.call(specialProds, prodName)) {
      var specialRhs = specialProds[prodName];
      if (specialRhs) {
        variantsOutput = specialRhs;
      } else {
        continue;
      }
    }

    // HACK: Include lexical productions so that every non-terminal on
    // a RHS appears in a LHS.
    if ('Literal' == prodName) {
      for (var specialName in specialProds) {
        if (Object.hasOwnProperty.call(specialProds, specialName)
            && !seen[specialName] && specialProds[specialName]) {
          output += specialName + ':'
              + variantBreak + specialProds[specialName] + '\n';
        }
      }
    }

    // Output the rule.
    output += prodName + ':' + variantBreak + variantsOutput + '\n';
  }
  document.querySelector('#text-grammar').appendChild(document.createTextNode(output));
</script>

*/


// Lexical Structure
(chapter=Literal)
Identifier:
     builtin // IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
IdentifierChars:
     builtin // JavaLetter {JavaLetterOrDigit}
IntegerLiteral:
     builtin
FloatingPointLiteral:
     builtin
BooleanLiteral:
     "false"
     "true"
CharacterLiteral:
     builtin
StringLiteral:
     builtin
NullLiteral:
     "null"
//JavaLetter:
//     any Unicode character that is a "Java letter"
//JavaLetterOrDigit:
//     any Unicode character that is a "Java letter-or-digit"
Literal:
     FloatingPointLiteral
     IntegerLiteral
     BooleanLiteral
     CharacterLiteral
     StringLiteral
     NullLiteral

// 4. Types, Values, and Variables
(chapter=Type)
Type:
     PrimitiveType
     ReferenceType
PrimitiveType:
     {Annotation} NumericType
     {Annotation} "boolean"
NumericType:
     IntegralType
     FloatingPointType
IntegralType:
     "byte"
     "short"
     "int"
     "long"
     "char"
FloatingPointType:
     "float"
     "double"
ReferenceType:
     ArrayType
     ClassOrInterfaceType
     TypeVariable
ClassOrInterfaceType:
     ClassType
     InterfaceType
ClassType:
     ContextFreeNames
     ClassOrInterfaceType "." {Annotation} Identifier [TypeArguments]
     {Annotation} Identifier [TypeArguments]
InterfaceType:
     ClassType
TypeVariable:
     {Annotation} Identifier
ArrayType:
     PrimitiveType Dims
     ClassOrInterfaceType Dims
     TypeVariable Dims
// This Dim production does not appear in the grammar, but including it here
// means that the presence of optional or repeated "[]" pairs results in an
// AST node.
Dim:
     "[" "]"
Dims:
     {Annotation} Dim {{Annotation} Dim}
TypeParameter:
     {TypeParameterModifier} Identifier [TypeBound]
TypeParameterModifier:
     Annotation
TypeBound:
     "extends" ClassOrInterfaceType {AdditionalBound}
     "extends" TypeVariable
AdditionalBound:
     "&" InterfaceType
TypeArguments:
     "<" TypeArgumentList ">"
TypeArgumentList:
     TypeArgument {"," TypeArgument}
TypeArgument:
     ReferenceType
     Wildcard
Wildcard:
     {Annotation} "?" [WildcardBounds]
WildcardBounds:
     "extends" ReferenceType
     "super" ReferenceType

// Names
(chapter=Name)
TypeName:
     !"@" ContextFreeNames
     PackageOrTypeName "." Identifier
     Identifier
PackageOrTypeName:
     !"@" ContextFreeNames
     PackageOrTypeName "." Identifier
     Identifier
ExpressionName:
     !"@" ContextFreeNames
     AmbiguousName "." Identifier
     Identifier
MethodName:
     Identifier
PackageName:
     !"@" ContextFreeNames
     PackageName "." Identifier
     Identifier
AmbiguousName:
     !"@" ContextFreeNames
     AmbiguousName "." Identifier
     Identifier

// ContextFreeNames matches a series of dotted names, possibly with
// annotations and/or type parameters.
// There are a number of productions like ClassType, InterfaceType, TypeVariable
// which are lexically ambiguous, so we order productions so that a parse
// reached ContextFreeNames first which allows a later pass to take into
// account scoping and declarations to disambiguate dotted identifier soup
// into approriate sub-trees.
// It is frequently the case also that a dotted name appears to the left of
// some variation of ("." [Stuff] Identifier).  This makes it easy for the
// parser to greedily match names and then borrow however many are necessary
// for the right.
ContextFreeNames:
      ContextFreeName {"." ContextFreeName}
ContextFreeName:
      {Annotation} Identifier [TypeArgumentsOrDiamond]


// Packages
(chapter=Package)
CompilationUnit:
     [PackageDeclaration] {ImportDeclaration} {TypeDeclaration}
PackageDeclaration:
     // TODO: Why is the package name here right-associative and only here?
     {PackageModifier} "package" Identifier {"." Identifier} ";"
PackageModifier:
     Annotation
ImportDeclaration:
     SingleTypeImportDeclaration
     TypeImportOnDemandDeclaration
     SingleStaticImportDeclaration
     StaticImportOnDemandDeclaration
SingleTypeImportDeclaration:
     "import" TypeName ";"
TypeImportOnDemandDeclaration:
     "import" PackageOrTypeName "." "*" ";"
SingleStaticImportDeclaration:
     "import" "static" TypeName "." Identifier ";"
StaticImportOnDemandDeclaration:
     "import" "static" TypeName "." "*" ";"
TypeDeclaration:
     ClassDeclaration
     InterfaceDeclaration
     ";"

// Classes
(chapter=Class)
ClassDeclaration:
     NormalClassDeclaration
     EnumDeclaration
NormalClassDeclaration:
     {ClassModifier} "class" Identifier [TypeParameters] [Superclass] [Superinterfaces] ClassBody
ClassModifier:
     Annotation
     "public"
     "protected"
     "private"
     "abstract"
     "static"
     "final"
     "strictfp"
TypeParameters:
     "<" TypeParameterList ">"
TypeParameterList:
     TypeParameter {"," TypeParameter}
Superclass:
     "extends" ClassType
Superinterfaces:
     "implements" InterfaceTypeList
InterfaceTypeList:
     InterfaceType {"," InterfaceType}
ClassBody:
     "{" {ClassBodyDeclaration} "}"
ClassBodyDeclaration:
     ClassMemberDeclaration
     InstanceInitializer
     StaticInitializer
     ConstructorDeclaration
ClassMemberDeclaration:
     FieldDeclaration
     MethodDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
FieldDeclaration:
     {FieldModifier} UnannType VariableDeclaratorList ";"
FieldModifier:
     Annotation
     "public"
     "protected"
     "private"
     "static"
     "final"
     "transient"
     "volatile"
VariableDeclaratorList:
     VariableDeclarator {"," VariableDeclarator}
VariableDeclarator:
     VariableDeclaratorId ["=" VariableInitializer]
VariableDeclaratorId:
     Identifier [Dims]
VariableInitializer:
     Expression
     ArrayInitializer
UnannType:
     UnannPrimitiveType
     UnannReferenceType
UnannPrimitiveType:
     NumericType
     "boolean"
UnannReferenceType:
     UnannArrayType
     UnannClassOrInterfaceType
     UnannTypeVariable
UnannClassOrInterfaceType:
     UnannClassType
     UnannInterfaceType
UnannClassType:
     !"@" ContextFreeNames
     Identifier [TypeArguments]
     UnannClassOrInterfaceType "." {Annotation} Identifier [TypeArguments]
UnannInterfaceType:
     UnannClassType
UnannTypeVariable:
     Identifier
UnannArrayType:
     UnannPrimitiveType Dims
     UnannClassOrInterfaceType Dims
     UnannTypeVariable Dims
MethodDeclaration:
     {MethodModifier} MethodHeader MethodBody
MethodModifier:
     Annotation
     "public"
     "protected"
     "private"
     "abstract"
     "static"
     "final"
     "synchronized"
     "native"
     "strictfp"
MethodHeader:
     Result MethodDeclarator [Throws]
     TypeParameters {Annotation} Result MethodDeclarator [Throws]
Result:
     UnannType
     "void"
MethodDeclarator:
     Identifier "(" [FormalParameterList] ")" [Dims]
FormalParameterList:
     ReceiverParameter
     FormalParameters "," LastFormalParameter
     LastFormalParameter
FormalParameters:
     FormalParameter {"," FormalParameter}
     ReceiverParameter {"," FormalParameter}
FormalParameter:
     {VariableModifier} UnannType VariableDeclaratorId
VariableModifier:
     Annotation
     "final"
LastFormalParameter:
     {VariableModifier} UnannType {Annotation} "..." VariableDeclaratorId
     FormalParameter
ReceiverParameter:
     {Annotation} UnannType [Identifier "."] "this"
Throws:
     "throws" ExceptionTypeList
ExceptionTypeList:
     ExceptionType {"," ExceptionType}
ExceptionType:
     ClassType
     TypeVariable
MethodBody:
     Block
     ";"
InstanceInitializer:
     Block
StaticInitializer:
     "static" Block
ConstructorDeclaration:
     {ConstructorModifier} ConstructorDeclarator [Throws] ConstructorBody
ConstructorModifier:
     Annotation
     "public"
     "protected"
     "private"
ConstructorDeclarator:
     [TypeParameters] SimpleTypeName "(" [FormalParameterList] ")"
SimpleTypeName:
     Identifier
ConstructorBody:
     "{" [ExplicitConstructorInvocation] [BlockStatements] "}"
ExplicitConstructorInvocation:
     [TypeArguments] "this" "(" [ArgumentList] ")" ";"
     [TypeArguments] "super" "(" [ArgumentList] ")" ";"
     Primary "." [TypeArguments] "super" "(" [ArgumentList] ")" ";"
     ExpressionName "." [TypeArguments] "super" "(" [ArgumentList] ")" ";"
EnumDeclaration:
     {ClassModifier} "enum" Identifier [Superinterfaces] EnumBody
EnumBody:
     "{" [EnumConstantList] [","] [EnumBodyDeclarations] "}"
EnumConstantList:
     EnumConstant {"," EnumConstant}
EnumConstant:
     {EnumConstantModifier} Identifier ["(" [ArgumentList] ")"] [ClassBody]
EnumConstantModifier:
     Annotation
EnumBodyDeclarations:
     ";" {ClassBodyDeclaration}

// Interfaces
(chapter=Interface)
InterfaceDeclaration:
     NormalInterfaceDeclaration
     AnnotationTypeDeclaration
NormalInterfaceDeclaration:
     {InterfaceModifier} "interface" Identifier [TypeParameters] [ExtendsInterfaces] InterfaceBody
InterfaceModifier:
     Annotation
     "public"
     "protected"
     "private"
     "abstract"
     "static"
     "strictfp"
ExtendsInterfaces:
     "extends" InterfaceTypeList
InterfaceBody:
     "{" {InterfaceMemberDeclaration} "}"
InterfaceMemberDeclaration:
     ConstantDeclaration
     InterfaceMethodDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
ConstantDeclaration:
     {ConstantModifier} UnannType VariableDeclaratorList ";"
ConstantModifier:
     Annotation
     "public"
     "static"
     "final"
InterfaceMethodDeclaration:
     {InterfaceMethodModifier} MethodHeader MethodBody
InterfaceMethodModifier:
     Annotation
     "public"
     "abstract"
     "default"
     "static"
     "strictfp"
AnnotationTypeDeclaration:
     {InterfaceModifier} "@" "interface" Identifier AnnotationTypeBody
AnnotationTypeBody:
     "{" {AnnotationTypeMemberDeclaration} "}"
AnnotationTypeMemberDeclaration:
     AnnotationTypeElementDeclaration
     ConstantDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
AnnotationTypeElementDeclaration:
     {AnnotationTypeElementModifier} UnannType Identifier "(" ")" [Dims] [DefaultValue] ";"
AnnotationTypeElementModifier:
     Annotation
     "public"
     "abstract"
DefaultValue:
     "default" ElementValue
Annotation:
     NormalAnnotation
     SingleElementAnnotation
     MarkerAnnotation
NormalAnnotation:
     "@" TypeName "(" [ElementValuePairList] ")"
ElementValuePairList:
     ElementValuePair {"," ElementValuePair}
ElementValuePair:
     Identifier "=" ElementValue
ElementValue:
     ConditionalExpression
     ElementValueArrayInitializer
     Annotation
ElementValueArrayInitializer:
     "{" [ElementValueList] [","] "}"
ElementValueList:
     ElementValue {"," ElementValue}
MarkerAnnotation:
     "@" TypeName
SingleElementAnnotation:
     "@" TypeName "(" ElementValue ")"

// Arrays
(chapter=Array)
ArrayInitializer:
     "{" [VariableInitializerList] [","] "}"
VariableInitializerList:
     VariableInitializer {"," VariableInitializer}

// Blocks and Statements
(chapter=Statement)
Block:
     "{" [BlockStatements] "}"
BlockStatements:
     BlockStatement {BlockStatement}
BlockStatement:
     LocalVariableDeclarationStatement
     ClassDeclaration
     Statement
LocalVariableDeclarationStatement:
     LocalVariableDeclaration ";"
LocalVariableDeclaration:
     {VariableModifier} UnannType VariableDeclaratorList
Statement:
     StatementWithoutTrailingSubstatement
     LabeledStatement
     IfThenElseStatement
     IfThenStatement
     WhileStatement
     ForStatement
StatementNoShortIf:
     StatementWithoutTrailingSubstatement
     LabeledStatementNoShortIf
     IfThenElseStatementNoShortIf
     WhileStatementNoShortIf
     ForStatementNoShortIf
StatementWithoutTrailingSubstatement:
     Block
     EmptyStatement
     ExpressionStatement
     AssertStatement
     SwitchStatement
     DoStatement
     BreakStatement
     ContinueStatement
     ReturnStatement
     SynchronizedStatement
     ThrowStatement
     TryStatement
EmptyStatement:
     ";"
LabeledStatement:
     Identifier ":" Statement
LabeledStatementNoShortIf:
     Identifier ":" StatementNoShortIf
ExpressionStatement:
     StatementExpression ";"
StatementExpression:
     Assignment
     PreExpression
     PostExpression
     MethodInvocation
     ClassInstanceCreationExpression
IfThenStatement:
     "if" "(" Expression ")" Statement
IfThenElseStatement:
     "if" "(" Expression ")" StatementNoShortIf "else" Statement
IfThenElseStatementNoShortIf:
     "if" "(" Expression ")" StatementNoShortIf "else" StatementNoShortIf
AssertStatement:
     "assert" Expression [":" Expression] ";"
SwitchStatement:
     "switch" "(" Expression ")" SwitchBlock
SwitchBlock:
     "{" {SwitchBlockStatementGroup} {SwitchLabel} "}"
SwitchBlockStatementGroup:
     SwitchLabels BlockStatements
SwitchLabels:
     SwitchLabel {SwitchLabel}
SwitchLabel:
     "case" ConstantExpression ":"
     "case" EnumConstantName ":"
     "default" ":"
EnumConstantName:
     Identifier
WhileStatement:
     "while" "(" Expression ")" Statement
WhileStatementNoShortIf:
     "while" "(" Expression ")" StatementNoShortIf
DoStatement:
     "do" Statement "while" "(" Expression ")" ";"
ForStatement:
     BasicForStatement
     EnhancedForStatement
ForStatementNoShortIf:
     BasicForStatementNoShortIf
     EnhancedForStatementNoShortIf
BasicForStatement:
     "for" "(" [ForInit] ";" [Expression] ";" [ForUpdate] ")" Statement
BasicForStatementNoShortIf:
     "for" "(" [ForInit] ";" [Expression] ";" [ForUpdate] ")" StatementNoShortIf
ForInit:
     StatementExpressionList
     LocalVariableDeclaration
ForUpdate:
     StatementExpressionList
StatementExpressionList:
     StatementExpression {"," StatementExpression}
EnhancedForStatement:
     "for" "(" {VariableModifier} UnannType VariableDeclaratorId ":" Expression ")" Statement
EnhancedForStatementNoShortIf:
     "for" "(" {VariableModifier} UnannType VariableDeclaratorId ":" Expression ")" StatementNoShortIf
BreakStatement:
     "break" [Identifier] ";"
ContinueStatement:
     "continue" [Identifier] ";"
ReturnStatement:
     "return" [Expression] ";"
ThrowStatement:
     "throw" Expression ";"
SynchronizedStatement:
     "synchronized" "(" Expression ")" Block
TryStatement:
     "try" Block [Catches] Finally
     "try" Block Catches
     TryWithResourcesStatement
Catches:
     CatchClause {CatchClause}
CatchClause:
     "catch" "(" CatchFormalParameter ")" Block
CatchFormalParameter:
     {VariableModifier} CatchType VariableDeclaratorId
CatchType:
     UnannClassType {"|" ClassType}
Finally:
     "finally" Block
TryWithResourcesStatement:
     "try" ResourceSpecification Block [Catches] [Finally]
ResourceSpecification:
     "(" ResourceList [";"] ")"
ResourceList:
     Resource {";" Resource}
Resource:
     {VariableModifier} UnannType VariableDeclaratorId "=" Expression

// Expressions
(chapter=Expression)
Primary:
     PrimaryNoNewArray
     ArrayCreationExpression
PrimaryNoNewArray:
     Literal
     ClassLiteral
     "this"
     TypeName "." "this"
     ClassInstanceCreationExpression
     FieldAccess
     ArrayAccess
     MethodInvocation
     MethodReference
     !CastExpression "(" Expression ")"
ClassLiteral:
     TypeName {Dim} "." "class"
     NumericType {Dim} "." "class"
     "boolean" {Dim} "." "class"
     "void" "." "class"
ClassInstanceCreationExpression:
     Primary "." UnqualifiedClassInstanceCreationExpression
     UnqualifiedClassInstanceCreationExpression
     ExpressionName "." UnqualifiedClassInstanceCreationExpression
UnqualifiedClassInstanceCreationExpression:
     "new" [TypeArguments] ClassOrInterfaceTypeToInstantiate "(" [ArgumentList] ")" [ClassBody]
ClassOrInterfaceTypeToInstantiate:
     ContextFreeNames
     {Annotation} Identifier {"." {Annotation} Identifier} [TypeArgumentsOrDiamond]
TypeArgumentsOrDiamond:
     TypeArguments
     "<>"
FieldAccess:
     Primary "." Identifier
     "super" "." Identifier
     TypeName "." "super" "." Identifier
ArrayAccess:
     PrimaryNoNewArray "[" Expression "]"
     ExpressionName "[" Expression "]"
MethodInvocation:
     Primary "." [TypeArguments] Identifier "(" [ArgumentList] ")"
     MethodName "(" [ArgumentList] ")"
     ExpressionName "." [TypeArguments] Identifier "(" [ArgumentList] ")"
     TypeName "." [TypeArguments] Identifier "(" [ArgumentList] ")"
     TypeName "." "super" "." [TypeArguments] Identifier "(" [ArgumentList] ")"
     "super" "." [TypeArguments] Identifier "(" [ArgumentList] ")"
ArgumentList:
     Expression {"," Expression}
MethodReference:
     Primary "::" [TypeArguments] Identifier
     ReferenceType "::" [TypeArguments] Identifier
     ExpressionName "::" [TypeArguments] Identifier
     "super" "::" [TypeArguments] Identifier
     TypeName "." "super" "::" [TypeArguments] Identifier
     ClassType "::" [TypeArguments] "new"
     ArrayType "::" "new"
ArrayCreationExpression:
     "new" PrimitiveType DimExprs [Dims]
     "new" ClassOrInterfaceType DimExprs [Dims]
     "new" PrimitiveType Dims ArrayInitializer
     "new" ClassOrInterfaceType Dims ArrayInitializer
DimExprs:
     DimExpr {DimExpr}
DimExpr:
     {Annotation} "[" Expression "]"
Expression:
     LambdaExpression
     AssignmentExpression
LambdaExpression:
     LambdaParameters "->" LambdaBody
LambdaParameters:
     Identifier
     "(" [FormalParameterList] ")"
     "(" InferredFormalParameterList ")"
InferredFormalParameterList:
     Identifier {"," Identifier}
LambdaBody:
     Expression
     Block
AssignmentExpression:
     Assignment
     ConditionalExpression
Assignment:
     LeftHandSide AssignmentOperator Expression
LeftHandSide:
     FieldAccess
     ArrayAccess
     ExpressionName
AssignmentOperator:
     "="
     "*="
     "/="
     "%="
     "+="
     "-="
     "<<="
     ">>="
     ">>>="
     "&="
     "^="
     "|="
ConditionalExpression:
     ConditionalOrExpression "?" Expression ":" ConditionalExpression
     ConditionalOrExpression "?" Expression ":" LambdaExpression
     ConditionalOrExpression
ConditionalOrExpression:
     ConditionalOrExpression "||" ConditionalAndExpression
     ConditionalAndExpression
ConditionalAndExpression:
     ConditionalAndExpression "&&" InclusiveOrExpression
     InclusiveOrExpression
InclusiveOrExpression:
     InclusiveOrExpression "|" ExclusiveOrExpression
     ExclusiveOrExpression
ExclusiveOrExpression:
     ExclusiveOrExpression "^" AndExpression
     AndExpression
AndExpression:
     AndExpression "&" EqualityExpression
     EqualityExpression
EqualityExpression:
     EqualityExpression EqualityOperator RelationalExpression
     RelationalExpression
EqualityOperator:
     "=="
     "!="
RelationalExpression:
     RelationalExpression RelationalOperator ShiftExpression
     RelationalExpression "instanceof" ReferenceType
     ShiftExpression
RelationalOperator:
     "<="
     ">="
     "<"
     ">"
ShiftExpression:
     ShiftExpression ShiftOperator AdditiveExpression
     AdditiveExpression
ShiftOperator:
     ">>>"
     "<<"
     ">>"
AdditiveExpression:
     AdditiveExpression AdditiveOperator MultiplicativeExpression
     MultiplicativeExpression
AdditiveOperator:
     "+"
     "-"
MultiplicativeExpression:
     MultiplicativeExpression MultiplicativeOperator UnaryExpression
     UnaryExpression
MultiplicativeOperator:
     "*"
     "/"
     "%"
UnaryExpression:
     UnaryExpressionNotPlusMinus
     PreExpression
     "+" UnaryExpression
     "-" UnaryExpression
PreExpression:
     IncrDecrOperator UnaryExpression
IncrDecrOperator:
     "++"
     "--"
UnaryExpressionNotPlusMinus:
     CastExpression
     PostfixExpression
     "~" UnaryExpression
     "!" UnaryExpression
PostfixExpression:
     PostExpression
     Primary
     ExpressionName
PostExpression:
     Primary IncrDecrOperator
     ExpressionName IncrDecrOperator
CastExpression:
     "(" PrimitiveType ")" UnaryExpression
     "(" ReferenceType {AdditionalBound} ")" UnaryExpressionNotPlusMinus
     "(" ReferenceType {AdditionalBound} ")" LambdaExpression
ConstantExpression:
     Expression

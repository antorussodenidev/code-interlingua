// This grammar is extracted from the "Java Language Specification"
// Chapter 19 which gathers together the grammar productions from
// the rest of the spec.
// https://docs.oracle.com/javase/specs/jls/se8/html/jls-19.html

// Section 2.4 of the JLS defines the syntax.
// The fixed-width sections are quoted, and "one of" productions are
// expanded to one per line.

// This grammar is examined by generate_parser_helpers.py to
// produce *ParSerHelper.java classes which are references in
// NodeType classes.
// If there is one in the source tree,
// or the production starts with "TODO" then no
// helper is generated.


/*

DERIVATION
==========
I produced the bulk of this file thus:

curl https://docs.oracle.com/javase/specs/jls/se8/html/jls-19.html \
    > /tmp/jls-19.html

And then adding the following to the bottom before the </body>,
loading it in a browser and copy/pasting the text form.

<pre id="text-grammar"></pre>
<script>
  function strip(s) {
    return String(s).replace(/^\s+|\s+$/g, '');
  }

  var specialProds = {
    Identifier: 'builtin',  // Lexical production
    IdentifierChars: 'builtin',
    JavaLetter: null,  // Not needed post-lex
    JavaLetterOrDigit: null,
    IntegerLiteral: 'builtin',
    FloatingPointLiteral: 'builtin',
    StringLiteral: 'builtin',
    CharacterLiteral: 'builtin',
  };

  var output = '';
  var prods = document.querySelectorAll('.production');
  var seen = {};
  for (var i = 0, n = prods.length; i !== n; ++i) {
    var prod = prods[i];
    var lhs  = prod.querySelector('.lhs');
    var rhs  = prod.querySelector('.rhs');
    var name = strip(lhs.textContent);
    var variant = [];
    var variants = [];
    function processRhs(rhsNodes) {
      for (var i = 0, n = rhsNodes.length; i !== n; ++i) {
        var rhsNode = rhsNodes[i];
        switch (rhsNode.nodeType) {
          case Node.TEXT_NODE:
            var text = strip(rhsNode.nodeValue);
            var parts = rhsNode.nodeValue.match(/\S+/g);
            if (parts) {
              for (var j = 0, m = parts.length; j !== m; ++j) {
                variant.push(parts[j]);
              }
            }
            break;
          case Node.ELEMENT_NODE:
            switch (rhsNode.tagName) {
              case 'BR':
                if (variant.length) {
                  variants.push(variant.join(' '));
                  variant.length = 0;
                }
                break;
              case 'A':  // Reference to production
                variant.push(strip(rhsNode.textContent));
                break;
              case 'SPAN':
                variant.push('/' + '*' + strip(rhsNode.textContent) + '*' + '/');
                break;
              case 'CODE':  // Literal.  Quoted strings in lexical grammar not here.
                variant.push('"' + strip(rhsNode.textContent) + '"');
                break;
              case 'PRE':
                processRhs(rhsNode.childNodes);
                break;
              default:
                throw new Error(rhs.tagName + ' not expected');
            }
            break;
        }
      }
    }
    processRhs(rhs.childNodes);
    if (variant.length) { variants.push(variant.join(' ')); }
    var variantBreak = '\n     ';
    var variantsOutput = variants.join(variantBreak);
    var noOneOf = variantsOutput.replace(/^\s*\(one of\)(?:\s*)/, '');
    if (noOneOf != variantsOutput) {
      variantsOutput = noOneOf.replace(/\s+/g, variantBreak);
    }
    // Handle lexical productions by mapping them to "builtin".
    var prodName = lhs.textContent.replace(/:$/, '');
    seen[prodName] = true;
    if (Object.hasOwnProperty.call(specialProds, prodName)) {
      var specialRhs = specialProds[prodName];
      if (specialRhs) {
        variantsOutput = specialRhs;
      } else {
        continue;
      }
    }

    // HACK: Include lexical productions so that every non-terminal on
    // a RHS appears in a LHS.
    if ('Literal' == prodName) {
      for (var specialName in specialProds) {
        if (Object.hasOwnProperty.call(specialProds, specialName)
            && !seen[specialName] && specialProds[specialName]) {
          output += specialName + ':'
              + variantBreak + specialProds[specialName] + '\n';
        }
      }
    }

    // Output the rule.
    output += prodName + ':' + variantBreak + variantsOutput + '\n';
  }
  document.querySelector('#text-grammar').appendChild(document.createTextNode(output));
</script>


CHANGES
=======
The expression grammar has been rewritten to make it PEG-compatible and statement
productions have been re-ordered for the same reason.

Name productions have been reworked because, in a context-free parse,
    foo
can be multiple of variable name, field name, interface type, class type, type variable
in many positions.


GRAMMAR SYNTAX
==============
The syntactic conventions are similar to those defined in JLS Chapter 2, but
instead of using a fixed-width font for literal tokens, double quotes are used.
The "one of ..." syntactic sugar is not used and there is a negative lookahead
explained below.

Productions are defined thus
```
NonTerminal:
    Variant1
    Variant2
```

where variants are on separate lines and are indented.
A variant is a sequence of
```
    [OptionalContent]
    {RepeatedContent}
    "LiteralToken"
    NonTerminalReference
    !NegativeLookahead
    !!PositiveLookahead
```

A variants body can be followed by annotations
```
    (@name=Name)
    @anon
```

(@name=Name) specifies an explicit name for the variant.
If not specified, the variant name is derived from the body tokens.

@anon specifies that no push/pop events are added to the output when
parsing using the variant.  This makes for much more manageable
expression sub-trees since every precedence layer does not introduce
an inner node.  Instead of the input "1" parsing as
   Expression.AssignemntExpression
   |
   +--AssignmentExpression.ConditionalExpression
      |
      +--ConditionalExpression.ConditionalOrExpression
         |
         +--ConditionalOrExpression.ConditionalAndExpression
            |
            +--ConditionalAndExpression.InclusiveOrExpression
               |
               +--...
                  |
                  +--Primary
                     |
                     +--Literal
                        |
                        +--IntLiteral
                          |
                           +--"1"

judicious use of @anon cuts out all the *Expression.*Expression variant
inner nodes which must have exactly one child which is itself a *Expression
inner node.

*/


// Lexical Structure
(chapter=Literal)
Identifier:
     builtin // IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
IdentifierChars:
     builtin // JavaLetter {JavaLetterOrDigit}
IntegerLiteral:
     builtin
FloatingPointLiteral:
     builtin
BooleanLiteral:
     "false"
     "true"
CharacterLiteral:
     builtin
StringLiteral:
     builtin
NullLiteral:
     "null"
JavaDocComment:
     builtin @ignorable
//JavaLetter:
//     any Unicode character that is a "Java letter"
//JavaLetterOrDigit:
//     any Unicode character that is a "Java letter-or-digit"
Literal:
     FloatingPointLiteral
     IntegerLiteral
     BooleanLiteral
     CharacterLiteral
     StringLiteral
     NullLiteral

// 4. Types, Values, and Variables
(chapter=Type)
Type:
     ReferenceType
     PrimitiveType
PrimitiveType:
     {Annotation} NumericType
     {Annotation} "boolean"
NumericType:
     IntegralType
     FloatingPointType
IntegralType:
     "byte"
     "short"
     "int"
     "long"
     "char"
FloatingPointType:
     "float"
     "double"
ReferenceType:
     ArrayType
     ClassOrInterfaceType
     TypeVariable
ClassOrInterfaceType:
     ContextFreeNames
     ClassType
     InterfaceType
ClassType:
     ContextFreeNames
     ClassOrInterfaceType "." {Annotation} Identifier [TypeArguments]
     {Annotation} Identifier [TypeArguments]
InterfaceType:
     ClassType
TypeVariable:
     {Annotation} Identifier
ArrayType:
     PrimitiveType Dims
     ClassOrInterfaceType Dims
     TypeVariable Dims
// This Dim production does not appear in the grammar, but including it here
// means that the presence of optional or repeated "[]" pairs results in an
// AST node.
Dim:
     "[" "]"
Dims:
     {Annotation} Dim {{Annotation} Dim}
TypeParameter:
     {TypeParameterModifier} Identifier [TypeBound]
TypeParameterModifier:
     Annotation
TypeBound:
     "extends" ClassOrInterfaceType {AdditionalBound}
     "extends" TypeVariable
AdditionalBound:
     "&" InterfaceType
TypeArguments:
     "<" TypeArgumentList ">"
TypeArgumentList:
     TypeArgument {"," TypeArgument}
TypeArgument:
     ReferenceType
     Wildcard
Wildcard:
     {Annotation} "?" [WildcardBounds]
WildcardBounds:
     "extends" ReferenceType
     "super" ReferenceType

// Names
(chapter=Name)
FieldName:
     Identifier
Label:
     Identifier
LocalName:
     Identifier
MethodName:
     Identifier
SimpleTypeName:
     Identifier
TypeName:
     !"@" ContextFreeNames
     PackageOrTypeName "." Identifier
     Identifier
PackageOrTypeName:
     !"@" ContextFreeNames
     PackageOrTypeName "." Identifier
     Identifier
ExpressionName:
     !"@" ContextFreeNames
     AmbiguousName "." Identifier
     Identifier
PackageName:
     !"@" ContextFreeNames
     PackageName "." Identifier
     Identifier
AmbiguousName:
     !"@" ContextFreeNames
     AmbiguousName "." Identifier
     Identifier

// ContextFreeNames matches a series of dotted names, possibly with
// annotations and/or type parameters.
// There are a number of productions like ClassType, InterfaceType, TypeVariable
// which are lexically ambiguous, so we order productions so that a parse
// reached ContextFreeNames first which allows a later pass to take into
// account scoping and declarations to disambiguate dotted identifier soup
// into approriate sub-trees.
// It is frequently the case also that a dotted name appears to the left of
// some variation of ("." [Stuff] Identifier).  This makes it easy for the
// parser to greedily match names and then borrow however many are necessary
// for the right.
ContextFreeNames:
      ContextFreeName {"." ContextFreeName}
ContextFreeName:
      {Annotation} Identifier [TypeArgumentsOrDiamond] (@name=Name)


// Packages
(chapter=Package)
CompilationUnit:
     [PackageDeclaration] {ImportDeclaration} {TypeDeclaration}
PackageDeclaration:
     // TODO: Why is the package name here not left-associative as it is under the names chapter?
     {PackageModifier} "package" Identifier {"." Identifier} ";" (@name=Declaration)
PackageModifier:
     Annotation
ImportDeclaration:
     SingleTypeImportDeclaration
     TypeImportOnDemandDeclaration
     SingleStaticImportDeclaration
     StaticImportOnDemandDeclaration
SingleTypeImportDeclaration:
     "import" TypeName ";"
TypeImportOnDemandDeclaration:
     "import" PackageOrTypeName "." "*" ";"
SingleStaticImportDeclaration:
     "import" "static" TypeName "." Identifier ";"
StaticImportOnDemandDeclaration:
     "import" "static" TypeName "." "*" ";"
TypeDeclaration:
     ClassDeclaration
     InterfaceDeclaration
     ";"

// Classes
(chapter=Class)
ClassDeclaration:
     NormalClassDeclaration
     EnumDeclaration
NormalClassDeclaration:
     [JavaDocComment] {ClassModifier} "class" SimpleTypeName [TypeParameters] [Superclass] [Superinterfaces] ClassBody (@name=Declaration)
ClassModifier:
     Annotation
     "public"
     "protected"
     "private"
     "abstract"
     "static"
     "final"
     "strictfp"
TypeParameters:
     "<" TypeParameterList ">"
TypeParameterList:
     TypeParameter {"," TypeParameter}
Superclass:
     "extends" ClassType
Superinterfaces:
     "implements" InterfaceTypeList
InterfaceTypeList:
     InterfaceType {"," InterfaceType}
ClassBody:
     "{" {ClassBodyDeclaration} "}"
ClassBodyDeclaration:
     ClassMemberDeclaration
     InstanceInitializer
     StaticInitializer
     ConstructorDeclaration
ClassMemberDeclaration:
     FieldDeclaration
     MethodDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
FieldDeclaration:
     [JavaDocComment] {FieldModifier} UnannType VariableDeclaratorList ";" (@name=Declaration)
FieldModifier:
     Annotation
     "public"
     "protected"
     "private"
     "static"
     "final"
     "transient"
     "volatile"
VariableDeclaratorList:
     VariableDeclarator {"," VariableDeclarator}
VariableDeclarator:
     VariableDeclaratorId ["=" VariableInitializer]
VariableDeclaratorId:
     Identifier [Dims]
VariableInitializer:
     Expression
     ArrayInitializer
UnannType:
     UnannReferenceType
     UnannPrimitiveType
UnannPrimitiveType:
     NumericType
     "boolean"
UnannReferenceType:
     UnannArrayType
     UnannClassOrInterfaceType
     UnannTypeVariable
UnannClassOrInterfaceType:
     ContextFreeNames
     UnannClassType
     UnannInterfaceType
UnannClassType:
     !"@" ContextFreeNames
     Identifier [TypeArguments]
     UnannClassOrInterfaceType "." {Annotation} Identifier [TypeArguments]
UnannInterfaceType:
     UnannClassType
UnannTypeVariable:
     Identifier
UnannArrayType:
     UnannPrimitiveType Dims
     UnannClassOrInterfaceType Dims
     UnannTypeVariable Dims
MethodDeclaration:
     [JavaDocComment] {MethodModifier} MethodHeader MethodBody (@name=Declaration)
MethodModifier:
     Annotation
     "public"
     "protected"
     "private"
     "abstract"
     "static"
     "final"
     "synchronized"
     "native"
     "strictfp"
MethodHeader:
     Result MethodDeclarator [Throws]
     TypeParameters {Annotation} Result MethodDeclarator [Throws]
Result:
     UnannType
     "void"
MethodDeclarator:
     MethodName "(" [FormalParameterList] ")" [Dims]
FormalParameterList:
     FormalParameters ["," LastFormalParameter]
     LastFormalParameter
FormalParameters:
     FormalParameter {"," FormalParameter}
     ReceiverParameter {"," FormalParameter}
FormalParameter:
     {VariableModifier} UnannType VariableDeclaratorId
VariableModifier:
     Annotation
     "final"
LastFormalParameter:
     {VariableModifier} UnannType {Annotation} "..." VariableDeclaratorId
     FormalParameter
ReceiverParameter:
     {Annotation} UnannType [SimpleTypeName "."] "this"
Throws:
     "throws" ExceptionTypeList
ExceptionTypeList:
     ExceptionType {"," ExceptionType}
ExceptionType:
     ClassType
     TypeVariable
MethodBody:
     Block
     ";"
InstanceInitializer:
     Block
StaticInitializer:
     "static" Block
ConstructorDeclaration:
     [JavaDocComment] {ConstructorModifier} ConstructorDeclarator [Throws] ConstructorBody (@name=Declaration)
ConstructorModifier:
     Annotation
     "public"
     "protected"
     "private"
ConstructorDeclarator:
     [TypeParameters] SimpleTypeName "(" [FormalParameterList] ")"
ConstructorBody:
     "{" [ExplicitConstructorInvocation] [BlockStatements] "}"
ExplicitConstructorInvocation:
     [TypeArguments] "this" "(" [ArgumentList] ")" ";"
     [TypeArguments] "super" "(" [ArgumentList] ")" ";"
     Primary "." [TypeArguments] "super" "(" [ArgumentList] ")" ";"
EnumDeclaration:
     [JavaDocComment] {ClassModifier} "enum" SimpleTypeName [Superinterfaces] EnumBody (@name=Declaration)
EnumBody:
     "{" [EnumConstantList] [","] [EnumBodyDeclarations] "}"
EnumConstantList:
     EnumConstant {"," EnumConstant}
EnumConstant:
     {EnumConstantModifier} FieldName ["(" [ArgumentList] ")"] [ClassBody]
EnumConstantModifier:
     Annotation
EnumBodyDeclarations:
     ";" {ClassBodyDeclaration}

// Interfaces
(chapter=Interface)
InterfaceDeclaration:
     NormalInterfaceDeclaration
     AnnotationTypeDeclaration
NormalInterfaceDeclaration:
     [JavaDocComment] {InterfaceModifier} "interface" SimpleTypeName [TypeParameters] [ExtendsInterfaces] InterfaceBody (@name=Declaration)
InterfaceModifier:
     Annotation
     "public"
     "protected"
     "private"
     "abstract"
     "static"
     "strictfp"
ExtendsInterfaces:
     "extends" InterfaceTypeList
InterfaceBody:
     "{" {InterfaceMemberDeclaration} "}"
InterfaceMemberDeclaration:
     ConstantDeclaration
     InterfaceMethodDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
ConstantDeclaration:
     [JavaDocComment] {ConstantModifier} UnannType VariableDeclaratorList ";" (@name=Declaration)
ConstantModifier:
     Annotation
     "public"
     "static"
     "final"
InterfaceMethodDeclaration:
     [JavaDocComment] {InterfaceMethodModifier} MethodHeader MethodBody (@name=Declaration)
InterfaceMethodModifier:
     Annotation
     "public"
     "abstract"
     "default"
     "static"
     "strictfp"
AnnotationTypeDeclaration:
     [JavaDocComment] {InterfaceModifier} "@" "interface" SimpleTypeName AnnotationTypeBody (@name=Declaration)
AnnotationTypeBody:
     "{" {AnnotationTypeMemberDeclaration} "}"
AnnotationTypeMemberDeclaration:
     AnnotationTypeElementDeclaration
     ConstantDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
AnnotationTypeElementDeclaration:
     [JavaDocComment] {AnnotationTypeElementModifier} UnannType MethodName "(" ")" [Dims] [DefaultValue] ";" (@name=Declaration)
AnnotationTypeElementModifier:
     Annotation
     "public"
     "abstract"
DefaultValue:
     "default" ElementValue
Annotation:
     NormalAnnotation
     SingleElementAnnotation
     MarkerAnnotation
NormalAnnotation:
     "@" TypeName "(" [ElementValuePairList] ")"
ElementValuePairList:
     ElementValuePair {"," ElementValuePair}
ElementValuePair:
     Identifier "=" ElementValue
ElementValue:
     ConditionalExpression
     ElementValueArrayInitializer
     Annotation
ElementValueArrayInitializer:
     "{" [ElementValueList] [","] "}"
ElementValueList:
     ElementValue {"," ElementValue}
MarkerAnnotation:
     "@" TypeName
SingleElementAnnotation:
     "@" TypeName "(" ElementValue ")"

// Arrays
(chapter=Array)
ArrayInitializer:
     "{" [VariableInitializerList] [","] "}"
VariableInitializerList:
     VariableInitializer {"," VariableInitializer}

// Blocks and Statements
(chapter=Statement)
Block:
     "{" [BlockStatements] "}"
BlockStatements:
     BlockStatement {BlockStatement}
BlockStatement:
     LocalVariableDeclarationStatement
     ClassDeclaration
     Statement
LocalVariableDeclarationStatement:
     LocalVariableDeclaration ";"
LocalVariableDeclaration:
     {VariableModifier} UnannType VariableDeclaratorList (@name=Declaration)
Statement:
     Block
     EmptyStatement
     ExpressionStatement
     AssertStatement
     SwitchStatement
     DoStatement
     BreakStatement
     ContinueStatement
     ReturnStatement
     SynchronizedStatement
     ThrowStatement
     TryStatement
     LabeledStatement
     IfStatement
     WhileStatement
     ForStatement
EmptyStatement:
     ";"
LabeledStatement:
     Label ":" Statement
ExpressionStatement:
     StatementExpression ";"
StatementExpression:
     Assignment
     PreExpression
     PostExpression
     MethodInvocation
     ClassInstanceCreationExpression
IfStatement:
     "if" "(" Expression ")" Statement "else" Statement
     "if" "(" Expression ")" Statement !"else"
AssertStatement:
     "assert" Expression [":" Expression] ";"
SwitchStatement:
     "switch" "(" Expression ")" SwitchBlock
SwitchBlock:
     "{" {SwitchBlockStatementGroup} {SwitchLabel} "}"
SwitchBlockStatementGroup:
     SwitchLabels BlockStatements
SwitchLabels:
     SwitchLabel {SwitchLabel}
SwitchLabel:
     "case" ConstantExpression ":"
     "case" EnumConstantName ":"
     "default" ":"
EnumConstantName:
     FieldName
WhileStatement:
     "while" "(" Expression ")" Statement
DoStatement:
     "do" Statement "while" "(" Expression ")" ";"
ForStatement:
     BasicForStatement
     EnhancedForStatement
BasicForStatement:
     "for" "(" [ForInit] ";" [Expression] ";" [ForUpdate] ")" Statement
ForInit:
     StatementExpressionList
     LocalVariableDeclaration
ForUpdate:
     StatementExpressionList
StatementExpressionList:
     StatementExpression {"," StatementExpression}
EnhancedForStatement:
     "for" "(" {VariableModifier} UnannType VariableDeclaratorId ":" Expression ")" Statement
BreakStatement:
     "break" [Label] ";"
ContinueStatement:
     "continue" [Label] ";"
ReturnStatement:
     "return" [Expression] ";"
ThrowStatement:
     "throw" Expression ";"
SynchronizedStatement:
     "synchronized" "(" Expression ")" Block
TryStatement:
     "try" Block [Catches] Finally
     "try" Block Catches
     TryWithResourcesStatement
Catches:
     CatchClause {CatchClause}
CatchClause:
     "catch" "(" CatchFormalParameter ")" Block
CatchFormalParameter:
     {VariableModifier} CatchType VariableDeclaratorId
CatchType:
     UnannClassType {"|" ClassType}
Finally:
     "finally" Block
TryWithResourcesStatement:
     "try" ResourceSpecification Block [Catches] [Finally]
ResourceSpecification:
     "(" ResourceList [";"] ")"
ResourceList:
     Resource {";" Resource}
Resource:
     {VariableModifier} UnannType VariableDeclaratorId "=" Expression

// Expressions
(chapter=Expression)
ExpressionAtom:
     UnqualifiedClassInstanceCreationExpression
     ArrayCreationExpression
     Literal
     ClassLiteral
     [TypeName "."] "this" (@name=This)
     [TypeName "."] "super" !"[" !!UsePrefix  (@name=Super)
     ClassType "::" [TypeArguments] "new"  (@name=ConstructorReference)
     ArrayType "::" "new"  (@name=ArrayConstructorReference)
     MethodName "(" [ArgumentList] ")" (@name=MethodInvocation)
     ContextFreeNames
     LocalName !!UsePrefix  (@name=Local)
     FieldName !!UsePrefix  (@name=FreeField)
     TypeName !!"."  (@name=StaticMember)
     ReferenceType !!"::"  (@name=StaticReference)
     !CastExpression "(" Expression ")"  (@name=Parenthesized)
Primary:
     Primary "." [TypeArguments] MethodName "(" [ArgumentList] ")"  (@name=MethodInvocation)
     Primary "::" [TypeArguments] MethodName  (@name=MethodReference)
     Primary "." UnqualifiedClassInstanceCreationExpression  (@name=InnerClassCreation)
     Primary "[" Expression "]"  (@name=ArrayAccess)
     !SimpleCallPrefix ContextFreeNames !DotKeywordDimsOrCtorRef (@name=Ambiguous)
     Primary "." FieldName  (@name=FieldAccess)
     ExpressionAtom @anon
LeftHandSide:
     Primary (@postcond=Postconds.Primary.FieldAccess)       (@name=FieldAccess)
     Primary (@postcond=Postconds.Primary.ArrayAccess)       (@name=ArrayAccess)
     Primary (@postcond=Postconds.Primary.ExpressionAtom.Local)     (@name=Local)
     Primary (@postcond=Postconds.Primary.ExpressionAtom.FreeField) (@name=FreeField)
     Primary (@postcond=Postconds.Primary.Ambiguous)                (@name=Ambiguous)
DotKeywordDimsOrCtorRef:
     "." "class"
     "." "new"
     "." "super"
     "." "this"
     Dims
     "::" [TypeArguments] "new"
SimpleCallPrefix:
     MethodName "("
MethodInvocation:
     Primary (@postcond=Postconds.Primary.MethodInvocation) (@name=ExplicitCallee)
     Primary (@postcond=Postconds.Primary.ExpressionAtom.MethodInvocation) (@name=ImplicitCallee)
ClassInstanceCreationExpression:
     Primary (@postcond=Postconds.Primary.ExpressionAtom.UnqualifiedClassInstanceCreationExpression) (@name=UnqualifiedClassInstanceCreationExpression)
     Primary (@postcond=Postconds.Primary.InnerClassCreation) (@name=QualifiedClassInstanceCreationExpression)
UsePrefix:
     "."
     "["
     "::"
ClassLiteral:
     TypeName {Dim} "." "class"
     NumericType {Dim} "." "class"
     "boolean" {Dim} "." "class"
     "void" "." "class"
UnqualifiedClassInstanceCreationExpression:
     "new" [TypeArguments] ClassOrInterfaceTypeToInstantiate "(" [ArgumentList] ")" [ClassBody]
ClassOrInterfaceTypeToInstantiate:
     {Annotation} Identifier {"." {Annotation} Identifier} [TypeArgumentsOrDiamond]
TypeArgumentsOrDiamond:
     TypeArguments
     "<>"
ArgumentList:
     Expression {"," Expression}
ArrayCreationExpression:
     "new" PrimitiveType Dims ArrayInitializer !"["
     "new" ClassOrInterfaceType Dims ArrayInitializer !"["
     "new" PrimitiveType DimExprs [Dims] !"["
     "new" ClassOrInterfaceType DimExprs [Dims] !"["
DimExprs:
     DimExpr {DimExpr}
DimExpr:
     {Annotation} "[" Expression "]"
Expression:
     Assignment
     LambdaExpression
     ConditionalExpression
LambdaExpression:
     LambdaParameters "->" LambdaBody
LambdaParameters:
     Identifier
     "(" [FormalParameterList] ")"
     "(" InferredFormalParameterList ")"
InferredFormalParameterList:
     Identifier {"," Identifier}
LambdaBody:
     Expression
     Block
Assignment:
     LeftHandSide AssignmentOperator Expression
AssignmentOperator:
     "="
     "*="
     "/="
     "%="
     "+="
     "-="
     "<<="
     ">>="
     ">>>="
     "&="
     "^="
     "|="
ConditionalExpression:
     ConditionalOrExpression "?" Expression ":" LambdaExpression
     ConditionalOrExpression "?" Expression ":" ConditionalExpression
     ConditionalOrExpression @anon
ConditionalOrExpression:
     ConditionalOrExpression "||" ConditionalAndExpression
     ConditionalAndExpression @anon
ConditionalAndExpression:
     ConditionalAndExpression "&&" InclusiveOrExpression
     InclusiveOrExpression @anon
InclusiveOrExpression:
     InclusiveOrExpression "|" ExclusiveOrExpression
     ExclusiveOrExpression @anon
ExclusiveOrExpression:
     ExclusiveOrExpression "^" AndExpression
     AndExpression @anon
AndExpression:
     AndExpression "&" EqualityExpression
     EqualityExpression @anon
EqualityExpression:
     EqualityExpression EqualityOperator RelationalExpression
     RelationalExpression @anon
EqualityOperator:
     "=="
     "!="
RelationalExpression:
     RelationalExpression RelationalOperator ShiftExpression
     RelationalExpression "instanceof" ReferenceType
     ShiftExpression @anon
RelationalOperator:
     "<="
     ">="
     "<"
     ">"
ShiftExpression:
     ShiftExpression ShiftOperator AdditiveExpression
     AdditiveExpression @anon
ShiftOperator:
     "<<"
     ">>>"
     ">>"
AdditiveExpression:
     AdditiveExpression AdditiveOperator MultiplicativeExpression
     MultiplicativeExpression @anon
AdditiveOperator:
     "+"
     "-"
MultiplicativeExpression:
     MultiplicativeExpression MultiplicativeOperator UnaryExpression
     UnaryExpression @anon
MultiplicativeOperator:
     "*"
     "/"
     "%"
UnaryExpression:
     CastExpression
     PreExpression
     PostExpression
     PrefixOperator UnaryExpression
     Primary @anon
PrefixOperator:
     "+"
     "-"
     "~"
     "!"
IncrDecrOperator:
     "++"
     "--"
PreExpression:
     IncrDecrOperator LeftHandSideExpression
PostExpression:
     LeftHandSideExpression IncrDecrOperator
LeftHandSideExpression:
     LeftHandSide @anon
     "(" LeftHandSideExpression ")"
CastExpression:
     "(" PrimitiveType ")" UnaryExpression (@name=Primitive)
     "(" ReferenceType {AdditionalBound} ")" !AmbiguousBinaryUnaryOperator UnaryExpression (@name=Reference)
     "(" ReferenceType {AdditionalBound} ")" LambdaExpression (@name=Lambda)
AmbiguousBinaryUnaryOperator:
     "+"
     "-"
ConstantExpression:
     Expression
